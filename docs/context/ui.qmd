---
title: "UI Layer Context"
format: html
---

## Purpose

Streamlit-based web interface for importing statements, viewing analytics, and correcting categorizations.

## Architecture

**Location**: `src/ui/`

**Pattern**: Router + Page modules

**Entry Point**: `src/web_app.py`

## Application Structure

### Router

**File**: `src/web_app.py`

**Responsibilities**:
- Session state initialization
- Tab-based navigation (Import / Analytics)
- Language switching (English/Spanish)
- Bank selection (top-bar dropdown, not sidebar)
- ML model loading and caching
- Page rendering delegation

**Key Setup**:
```python
@st.cache_resource
def get_ml_engine():
    engine = ml.TransactionCategorizer()
    if engine.load_model():
        return engine
    ml.train_global_model()
    engine.load_model()
    return engine

ML_ENGINE = get_ml_engine()

# Two-tab navigation
tab_import, tab_analytics = st.tabs([t("nav_import"), t("nav_analytics")])
with tab_import:
    render_import_page(...)
with tab_analytics:
    render_analytics_dashboard(...)
```

**Bank/language controls** live in the top bar (3 columns: title, language, bank).
Sidebar is info-only (rules status, welcome text).

---

### Import Page

**File**: `src/ui/pages/import_page.py`

**Entry function**: `render_import_page(...)`

**Features**:
1. Quick-start expander (bank-specific tips)
2. Dual file uploaders: main statement + optional PDF
3. OCR checkbox (shown when PDF uploaded)
4. Process button → `imp.run_import_script()`
5. Results: success banner, Copy-to-Analytics button, logs expander, 3 result tabs (CSV / Unknown / Suggestions)
6. Download buttons for CSV and suggestions YAML

#### Session State Pattern — Persistent Results

Results are stored in `st.session_state` so they survive re-runs from widget interactions:

```python
RESULTS_KEY = f"import_results_{bank_id}"

# After successful run:
st.session_state[RESULTS_KEY] = {
    "returncode": res.returncode,
    "stdout": res.stdout,
    "stderr": res.stderr,
    "out_csv": str(out_csv),
    "out_unknown": str(out_unknown),
    "out_suggestions": str(out_suggestions),
    "pdf_path": str(pdf_path) if pdf_path else None,
}

# On every re-run, render from session state:
results = st.session_state.get(RESULTS_KEY)
if results:
    _render_import_results(results, ...)
```

**Auto-clear**: When the user uploads a different file, cached results for that bank are cleared:
```python
if uploaded_main is not None and st.session_state.get(f"{RESULTS_KEY}_file_name") != uploaded_main.name:
    st.session_state.pop(RESULTS_KEY, None)
    st.session_state[f"{RESULTS_KEY}_file_name"] = uploaded_main.name
```

**Navigation after copy**: Use `st.rerun()` (not the deprecated `st.experimental_rerun()`):
```python
st.session_state[nav_key] = t("nav_analytics")
st.rerun()
```

**Copy-to-Analytics robustness**:
- `render_import_page(...)` now passes both `bank_label` and `bank_id` to `copy_csv_to_analysis(...)`.
- This avoids false "unknown bank" errors when localized/display labels differ from analytics target keys.

---

### Analytics Page

**File**: `src/ui/pages/analytics_page.py`

**Entry function**: `render_analytics_dashboard(*, t, tc, config_dir, data_dir, copy_feedback_key, ml_engine)`

**Structure**:
- Loads bank transactions via `data_service.load_transactions(..., prefer_db=True)` using `data/ledger.db` when available (CSV fallback otherwise)
- Creates tabs dynamically (Santander, HSBC, and/or Comparison) based on which CSVs exist
- Delegates to `render_bank_analytics()` per bank
- Delegates to `render_comparison()` for side-by-side view

#### render_bank_analytics

**Signature**: `render_bank_analytics(df, bank_name, bank_id, t, tc, config_dir, data_dir, ml_engine)`

> **Note**: `stats` is NOT a parameter. Stats are computed *inside* this function after
> applying date/period filters, so they always match the current filter state.

**Workflow inside `render_bank_analytics`**:
1. Show last-updated timestamp
2. Render date range pickers + period selector
3. Apply filters to `df` → `df_filtered_for_display`
4. Call `calculate_categorization_stats(df, period=..., start_date=..., end_date=...)`
5. Call reusable component functions from `analytics_components.py`
6. Call `_render_drilldown()`
7. Call `_render_rule_hub()`

**Do not** pre-compute stats in the caller and pass them — they will be recomputed inside.

#### Dashboard Sections

| Section | Function | Source |
|---------|----------|--------|
| Metrics (5 cards) | `render_metrics(t, stats)` | `analytics_components.py` |
| Charts (3 charts) | `render_charts(t, stats, tc)` | `analytics_components.py` |
| Category deep dive | `render_category_deep_dive(t, tc, stats)` | `analytics_components.py` |
| Monthly trends | `render_monthly_spending_trends(t, tc, stats)` | `analytics_components.py` |
| Transaction drilldown | `_render_drilldown(t, tc, stats, df_filtered, bank_id)` | inline |
| Rule Hub | `_render_rule_hub(t, tc, df_filtered, bank_name, bank_id, config_dir, data_dir, ml_engine)` | inline |

#### Filtering System

**Period Filter** (from `period:YYYY-MM` tags):
```python
periods = {tag.split(":")[1] for tag_str in df["tags"].dropna()
           for tag in str(tag_str).split(",") if tag.startswith("period:")}
selected_period = st.selectbox("Filter", [t("all")] + sorted(periods, reverse=True))
```

**Date Range Filter** (overrides period filter when both dates set):
```python
start_date_filter = st.date_input(t("start_date_filter"), value=None)
end_date_filter = st.date_input(t("end_date_filter"), value=None)
date_range_active = start_date_filter and end_date_filter and start_date_filter <= end_date_filter
```

**Priority**: Date range filter disables period selector when active.

#### Rule Correction Workflow

**Sequence**:
1. Expand "Rule Hub" section
2. Optional fuzzy merchant search (smart_matching)
3. ML prediction shown with confidence score (wrapped in try/except — never crashes page)
4. Select category from dropdown
5. Edit expense account and regex pattern
6. "Stage Rule Change" → `rulesvc.stage_rule_change(..., db_path=data_dir / "ledger.db")`
7. "Apply Pending Rules" → `rulesvc.merge_pending_rules(..., db_path=data_dir / "ledger.db")` → `ml.train_global_model()` → `st.cache_resource.clear()`

**ML prediction (safe pattern)**:
```python
ml_predictions = []
suggested_cat_hub = None
try:
    ml_predictions = ml_engine.predict(selected_merchant) or []
    if ml_predictions:
        top_cat, confidence = ml_predictions[0]
        if confidence > 0.3:
            st.success(t("ml_prediction", cat=top_cat, conf=confidence))
            if ":" in top_cat:
                suggested_cat_hub = top_cat.split(":")[-1]
except Exception:
    st.caption("ML prediction unavailable")
```

#### render_comparison

Renders side-by-side Santander vs HSBC breakdown:
- 3-column metrics (totals + combined)
- Two pie charts (spending by category per bank)
- Grouped bar chart (combined category spending)
- Two coverage pies

**Signature**: `render_comparison(df_sant, df_hsbc, *, t, tc=None)`

---

## Session State Keys Reference

| Key | Type | Set by | Purpose |
|-----|------|--------|---------|
| `lang` | `str` | `web_app.py` | Current language (`"en"` or `"es"`) |
| `bank_select` | `str` | `web_app.py` | Selected bank display name |
| `nav_page` | `str` | `import_page.py` | Navigate to tab after copy |
| `copy_feedback` | `str` | `import_page.py` | Success message for analytics tab |
| `import_results_{bank_id}` | `dict` | `import_page.py` | Persisted import run output |
| `import_results_{bank_id}_file_name` | `str` | `import_page.py` | Last uploaded filename (for cache invalidation) |

---

## Translation System

**File**: `src/translations.py`

**Functions** (defined in `web_app.py`):
```python
def t(key: str, **kwargs) -> str:
    """Translate UI text. Returns key itself if not found."""
    lang = st.session_state.lang
    text = TRANSLATIONS[lang].get(key, key)
    return text.format(**kwargs) if kwargs else text

def tc(category: str) -> str:
    """Translate category name (e.g. 'groceries' → 'Abarrotes')."""
    return t(f"cat_{category.lower()}")
```

**Usage**: Always use `t()` for user-visible strings. Never hardcode English text directly in UI.

**Languages**: English (`en`), Spanish (`es`)

---

## Shared Components

**File**: `src/ui/components/analytics_components.py`

```python
render_metrics(t, stats)
# → 5 st.metric cards (total, spent, categorized%, category%, withdrawals)

render_charts(t, stats, tc)
# → 3 Plotly charts (coverage pie, type bar, spending pie)

render_category_deep_dive(t, tc, stats)
# → Top-10 bars (count + spending) + summary table

render_monthly_spending_trends(t, tc, stats)
# → Multi-line spending trend chart
```

These are called from `render_bank_analytics` (not from the comparison view).

---

## Plotly Chart Conventions

All charts use consistent dark-theme settings:
```python
fig = px.pie(names=[...], values=[...], hole=0.6,
             template="plotly_dark",
             color_discrete_sequence=px.colors.qualitative.Set2)
fig.update_traces(textposition="inside", textinfo="percent+label")
fig.update_layout(showlegend=False, height=400, font_family="Outfit")
st.plotly_chart(fig, use_container_width=True)
```

**Chart types used**:
- `px.pie()` — Categorization coverage, spending share
- `px.bar()` — Transaction types, category counts/spending (horizontal)
- `px.line()` — Monthly spending trends
- `go.Figure()` with `go.Bar()` — Grouped bank comparison

---

## UI Development Patterns

### Persistent results across re-runs
```python
# Store after long operation
st.session_state["my_results"] = result_dict

# Render from state (runs every re-run)
if results := st.session_state.get("my_results"):
    _render_results(results)
```

### Safe navigation (rerun to switch tab)
```python
st.session_state[nav_key] = t("nav_analytics")
st.rerun()   # not st.experimental_rerun()
```

### Wrap external calls that may fail
```python
try:
    predictions = ml_engine.predict(text)
except Exception:
    st.caption("Prediction unavailable")
    predictions = []
```

### Cache expensive operations
```python
@st.cache_resource          # for objects (ML model, DB connections)
def get_ml_engine(): ...

@st.cache_data              # for data (config files, static CSV)
def get_banks_config(): ...
```

### Handle empty states early
```python
if df.empty:
    st.warning(t("no_data"))
    return
```

---

## Running the App

```bash
# Development
streamlit run src/web_app.py

# Or via script
./scripts/run_web.sh
```

**URL**: `http://localhost:8501`

---

## CodeGraph Navigation for UI

The UI layer calls services — use CodeGraph to trace data flow without reading all UI code:

```bash
# Find all UI page functions
codegraph_search "analytics_page"
codegraph_search "render_"

# Trace what services a UI page calls
codegraph_callees "render_analytics_dashboard"
codegraph_callees "render_bank_analytics"

# Find which UI components call a service function
codegraph_callers "calculate_categorization_stats"
codegraph_callers "stage_rule_change"

# Check impact before changing a service (which UI breaks?)
codegraph_impact "load_transactions_from_csv"
codegraph_impact "merge_pending_rules"

# Inspect component source for Streamlit widget keys
codegraph_node "render_bank_analytics"
codegraph_node "_render_rule_hub"
```

**Important**: UI is excluded from coverage enforcement. Use `codegraph_callers` to verify services before refactoring.

---

## Related Files

- `src/web_app.py` - App router, CSS theme, ML caching
- `src/ui/pages/import_page.py` - Import workflow
- `src/ui/pages/analytics_page.py` - Analytics dashboard + Rule Hub
- `src/ui/components/analytics_components.py` - Reusable chart/metric components
- `src/translations.py` - Bilingual string dictionary
- `src/services/data_service.py` - DB-first transaction loading + CSV fallback
- `src/services/analytics_service.py` - Stats calculation
- `src/services/rule_service.py` - Rule staging/merging
- `src/ml_categorizer.py` - ML predictions
- `src/smart_matching.py` - Fuzzy merchant search
