---
title: "ML & Categorization Context"
format: html
---

## Purpose

Machine learning category predictions and smart merchant matching for automated transaction categorization.

## ML Categorization

### File

**`src/ml_categorizer.py`**

### Model Architecture

**Algorithm**: sklearn `LogisticRegression` inside a `Pipeline`
**Features**: `TfidfVectorizer(ngram_range=(1, 2), max_features=1000)` on transaction descriptions
**Training Data**: Existing Firefly CSV exports under `data/**/*.csv` (filtered to filenames containing `firefly`)

### Key Functions

```python
def train_global_model() -> str:
    """Train model from Firefly CSV history and persist joblib artifact."""
    # 1. Discover firefly CSVs in data/
    # 2. Train TransactionCategorizer from withdrawal rows
    # 3. Save to config/ml_models/categorizer_v1.joblib
    # 4. Return status message

class TransactionCategorizer:
    def predict(self, description: str) -> List[Tuple[str, float]]:
        """Predict destination account labels from a transaction description.

        Returns:
            List of (destination_name, confidence) tuples, sorted by confidence
        """
        # 1. Return [] when model is not trained
        # 2. Run predict_proba against pipeline
        # 3. Keep predictions above 0.1 probability
```

### Training Process

**Data Source**: historical CSV transaction files (not `rules.yml`)
**Required Columns**: `description`, `destination_name`
**Filter**: only rows with `type == "withdrawal"` are used when that column exists

**Training**:
1. Discover CSV files from `data/`
2. Keep import CSVs with `firefly` in filename
3. Build training frame from `description` + `destination_name`
4. Train `TfidfVectorizer + LogisticRegression`
5. Persist model with `joblib`

**Retraining Triggers**:
- On web app startup when no persisted model is available
- Manual retraining by calling `train_global_model()` (CLI or code path)

### Prediction Usage

**In Categorization Flow**:
```python
from ml_categorizer import TransactionCategorizer, train_global_model

engine = TransactionCategorizer()
if not engine.load_model():
    train_global_model()
    engine.load_model()

# For each transaction
predictions = engine.predict("OXXO STORE 123")

if predictions:
    destination_name, confidence = predictions[0]
    if confidence > 0.3:  # Confidence threshold
        assign_destination(destination_name)
```

**In UI Rule Hub**:
```python
# Show ML suggestion to user
predictions = ml_engine.predict(selected_merchant)
if predictions:
    top_cat, conf = predictions[0]
    st.success(f"ML suggests: {top_cat} ({conf:.0%})")
```

### Model Characteristics

**Strengths**:
- Fast training (milliseconds)
- Good for text classification
- Handles Spanish merchant names well
- Probabilistic output (confidence scores)

**Limitations**:
- Requires enough labeled CSV history (`len(data) >= 5`)
- Predictions are account labels, not normalized category IDs
- Model quality depends on prior categorizations in CSVs

**Typical Confidence Ranges**:
- > 0.7: High confidence, likely correct
- 0.3-0.7: Medium confidence, review recommended
- < 0.3: Low confidence, manual review needed

## Smart Matching

### File

**`src/smart_matching.py`**

### Purpose

Fuzzy string matching for merchant search in UI

### Key Function

```python
def find_similar_merchants(
    query: str,
    merchant_list: List[str],
    threshold: int = 50
) -> List[Tuple[str, int]]:
    """Find merchants similar to query using fuzzy matching.

    Args:
        query: Search term
        merchant_list: List of merchant names
        threshold: Minimum similarity score (0-100)

    Returns:
        List of (merchant, score) tuples, sorted by score descending
    """
```

### Algorithm

**Library**: rapidfuzz
**Method**: Levenshtein distance with optimizations

**Scoring**: 0-100 scale
- 100 = exact match
- 90+ = very similar (typo tolerance)
- 70-89 = similar
- 50-69 = somewhat similar
- < 50 = not similar (filtered out)

### Usage in UI

**Merchant Search**:
```python
import smart_matching as sm

# User types search term
search_term = st.text_input("Search merchant", "")

if search_term:
    # Find similar merchants
    matches = sm.find_similar_merchants(
        search_term,
        merchant_list,
        threshold=50
    )

    if matches:
        # Filter merchant list to matches
        merchant_list = [m for m, _score in matches]
    else:
        st.warning("No similar merchants found")
```

**Benefits**:
- Typo tolerance ("oxxo" matches "OXXO")
- Partial matching ("star" matches "STARBUCKS")
- Fast searching through large merchant lists
- Case-insensitive matching

## Rule-Based Categorization

### Configuration

**File**: `config/rules.yml`

**Structure**:
```yaml
categorization_rules:
  - merchant: "OXXO"                          # Display name
    regex: "OXXO.*"                           # Matching pattern
    expense_account: "Expenses:Food:Groceries" # Firefly account
    bucket_tag: "groceries"                   # Category tag

  - merchant: "Uber"
    regex: "UBER.*"
    expense_account: "Expenses:Transport:Uber"
    bucket_tag: "transport"
```

### Matching Logic

**Priority**: Rules are checked in order
**First Match Wins**: Stop after first regex match

**Process**:
```python
for rule in categorization_rules:
    pattern = re.compile(rule["regex"], re.IGNORECASE)
    if pattern.match(description):
        return rule["expense_account"], rule["bucket_tag"]

# No match → try ML prediction
ml_predictions = ml_engine.predict(description)
if ml_predictions and ml_predictions[0][1] > 0.3:
    return ml_predictions[0][0], extract_tag(ml_predictions[0][0])

# Still no match → uncategorized
return "Uncategorized", None
```

## Safe Rule Workflow

### Staging Rules

**File**: `config/rules.pending.yml`

**Purpose**: Stage rule changes before merging to main rules

**Structure**: Same as `rules.yml`

**Workflow**:
1. User corrects category in UI
2. Rule added to `rules.pending.yml`
3. Conflict detection runs
4. User reviews pending rules
5. Batch apply when ready

### Conflict Detection

**Check**: Duplicate regex patterns

**Process**:
```python
# Load main rules
main_rules = load_rules("config/rules.yml")

# Load pending rules
pending_rules = load_rules("config/rules.pending.yml")

# Check for conflicts
for pending in pending_rules:
    for main in main_rules:
        if pending["regex"] == main["regex"]:
            # Conflict found
            conflicts.append({
                "rule": pending["merchant"],
                "conflicts": [main["merchant"]]
            })
```

**Resolution**: User must edit pending rules to fix conflicts

### Merging Rules

**Process**:
1. Create backup: `config/backups/rules_YYYYMMDD_HHMMSS.yml`
2. Append pending rules to main rules
3. Write updated main rules
4. Clear pending rules file
5. Retrain ML model
6. Clear Streamlit cache

**Code**:
```python
from services.rule_service import merge_pending_rules

ok, result = merge_pending_rules(
    rules_path=Path("config/rules.yml"),
    pending_path=Path("config/rules.pending.yml"),
    backup_dir=Path("config/backups")
)

if ok:
    # Retrain ML
    ml.train_global_model()
    st.cache_resource.clear()
```

## Merchant Tagging

### Automatic Tags

**Generated for each transaction**:

```python
# From description "OXXO STORE 123"
merchant_tag = "merchant:oxxo_store_123"

# From statement period
period_tag = "period:2024-01"

# Combined
tags = "merchant:oxxo_store_123,period:2024-01"
```

**Normalization**:
- Lowercase
- Replace spaces with underscores
- Remove special characters
- Keep alphanumeric and underscores

**Purpose**:
- Enable merchant-based filtering
- Support fuzzy search
- Track spending by merchant
- Period-based analytics

## Category Hierarchy

### Firefly III Structure

**Format**: `Expenses:Parent:Child`

**Examples**:
```
Expenses:Food:Groceries
Expenses:Food:Restaurants
Expenses:Transport:Uber
Expenses:Transport:Gas
Expenses:Shopping:Clothing
Expenses:Entertainment:Streaming
```

### Common Categories

**Pre-defined in UI**:
- Groceries
- Restaurants
- Transport
- Shopping
- Subscriptions
- Entertainment
- Health
- Fees
- Online

### Category Extraction

**From Full Account Path**:
```python
# "Expenses:Food:Groceries" → "Groceries"
if ":" in destination_name:
    category = destination_name.split(":")[-1]
else:
    category = destination_name
```

## Testing

**ML Model**:
- Trained on rules at startup
- Predictions validated manually
- No automated tests (model quality depends on rules)

**Smart Matching**:
- `tests/test_generic_importer.py` includes determinism test
- Fuzzy matching behavior verified manually

**Categorization**:
- `tests/test_analytics_service.py` validates categorization detection
- `is_categorized()` function tested with multiple cases

## CodeGraph Navigation for ML & Categorization

Use CodeGraph to understand the categorization pipeline before adding rules or retraining:

```bash
# Discover all categorization functions
codegraph_search "ml_categorizer"
codegraph_search "train_global_model"
codegraph_search "smart_matching"

# Trace who calls the ML model (to understand training trigger points)
codegraph_callers "train_global_model"
codegraph_callers "predict"

# Find what the ML model depends on (rules loading)
codegraph_callees "train_global_model"
codegraph_callees "TransactionCategorizer"

# Check blast radius of rule changes
codegraph_impact "stage_rule_change"
codegraph_impact "merge_pending_rules"

# Get full source for model architecture
codegraph_node "TransactionCategorizer"
codegraph_node "find_similar_merchants"
```

**Before retraining / adding rules:**
1. `codegraph_callers "train_global_model"` — find all retraining triggers
2. `codegraph_callees "train_global_model"` — understand training data sources
3. Add rule to `config/rules.pending.yml` → merge → retrain automatically

## Related Files

- `src/ml_categorizer.py` - ML model
- `src/smart_matching.py` - Fuzzy search
- `src/services/rule_service.py` - Rule management
- `config/rules.yml` - Main rules
- `config/rules.pending.yml` - Staged rules
- `config/backups/` - Rule backups
- `src/ui/pages/analytics_page.py` - Rule Hub UI
- `tests/test_analytics_service.py` - Categorization tests
